[gd_scene load_steps=23 format=3 uid="uid://dic8mtgfhdjc4"]

[ext_resource type="Script" path="res://Gravity Object/CameraPivot.gd" id="1_uivi6"]
[ext_resource type="PackedScene" uid="uid://dksa8p1sbkj5j" path="res://Corpos/sol.tscn" id="2_kb70h"]
[ext_resource type="PackedScene" uid="uid://c8yyn6e5cc28d" path="res://Corpos/planeta1.tscn" id="3_vnnaq"]
[ext_resource type="Script" path="res://Gravity Object/GravityObject.gd" id="4_tpk38"]
[ext_resource type="Material" uid="uid://be7um6c7rbo36" path="res://media/ballShader.tres" id="5_d1wt7"]
[ext_resource type="Texture2D" uid="uid://cafjpri876dco" path="res://media/SpaceSkyMap.png" id="6_x4oj4"]
[ext_resource type="Texture2D" uid="uid://u816heplxqi4" path="res://UI_source/minecraft_toolbar.png" id="7_u3wvk"]
[ext_resource type="Texture2D" uid="uid://dodcvc066alkq" path="res://UI_source/jupiter.png" id="8_wjos7"]
[ext_resource type="Script" path="res://UI_source/DragNDropTest.gd" id="9_wwimo"]
[ext_resource type="Script" path="res://Gravity Object/AnalyticPause.gd" id="10_cwwdn"]
[ext_resource type="PackedScene" uid="uid://cpomwl56g8js4" path="res://SaveAndLoad/SaveAndLoad.tscn" id="11_ft4fd"]

[sub_resource type="GDScript" id="GDScript_d487t"]
script/source = "extends Node3D
class_name TrailRenderer

#############################
# EXPORT PARAMS
#############################
# width
@export var width: float = 0.5
@export var width_curve: Curve
# length
@export var max_points := 100
@export var material: Material
# show or hide
@export var render: bool = true


#############################
# PARAMS
#############################
@onready var half_width = width * 0.5
var points := []




#############################
# OVERRIDE FUNCTIONS
#############################
func _ready() -> void:
	var node = Node.new()
	node.name = \"Node\"
	add_child(node)
	
	var render = MeshInstance3D.new() # Mudou de MeshInstance para MeshInstance3D
	render.name = \"Render\"
	node.add_child(render)


func _process(delta: float) -> void:
	if render:
		# add new point and render
		add_point()
		_draw_trail()
	else:
		# slowly hide the trail
		if points.size() > 0:
			var last_point = points.pop_back()
			last_point.queue_free()


#############################
# API
#############################
func add_point() -> void:
	var new_point = Marker3D.new() # Mudou de Position3D para Marker3D
	new_point.transform.origin = self.global_transform.origin # Mudou de translation para transform.origin
	new_point.rotation = self.global_transform.basis.get_euler()
	points.insert(0, new_point)
	if points.size() > max_points:
		var last_point = points.pop_back()
		last_point.queue_free()


func _draw_trail() -> void:
	if points.size() < 2:
		return
	# create surface tool
	var st = SurfaceTool.new()
	st.begin(Mesh.PRIMITIVE_TRIANGLES)
	# draw triangles
	for i in range(points.size() - 1):
		_points_to_rect(st, points[i], points[i + 1], i)
	# commit
	st.generate_normals()
#	st.generate_tangents()
	$Node/Render.mesh = st.commit()
	$Node/Render.set_surface_material(0, material)

func _points_to_rect(st: SurfaceTool, p1: Marker3D, p2: Marker3D, idx: float) -> void: # Mudou de Position3D para Marker3D nos parÃ¢metros
	var num_points = points.size() - 1
	
	var offset1 = idx / num_points
	var mod1 = half_width * width_curve.get_value(offset1, false) # Mudou de interpolate para get_value e adicionou o argumento loop_wrap
	
	var v1 = p1.transform.origin + p1.transform.basis.x * mod1 # Mudou de translation para transform.origin
	var uv1 = Vector2(0, offset1)
	
	var v2 = p1.transform.origin - p1.transform.basis.x * mod1 # Mudou de translation para transform.origin
	var uv2 = Vector2(1, offset1)
	
	var offset2 = (idx + 1) / num_points
	var mod2 = half_width * width_curve.get_value(offset2, false) # Mudou de interpolate para get_value e adicionou o argumento loop_wrap
	
	var v3 = p2.transform.origin + p2.transform.basis.x * mod2 # Mudou de translation para transform.origin
	var uv3 = Vector2(0, offset2)
	
	var v4 = p2.transform.origin - p2.transform.basis.x * mod2 # Mudou de translation para transform.origin
	var uv4 = Vector2(1, offset2)
	
	st.add_uv(uv1)
	st.add_vertex(v1)
	st.add_uv(uv2)
	st.add_vertex(v2)
	st.add_uv(uv3)
	st.add_vertex(v3)
	
	st.add_uv(uv3)
	st.add_vertex(v3)
	st.add_uv(uv2)
	st.add_vertex(v2)
	st.add_uv(uv1)
	st.add_vertex(v1)
	
	st.add_uv(uv3)
	st.add_vertex(v3)
	st.add_uv(uv4)
	st.add_vertex(v4)
	st.add_uv(uv2)
	st.add_vertex(v2)
	
	st.add_uv(uv2)
	st.add_vertex(v2)
	st.add_uv(uv4)
	st.add_vertex(v4)
	st.add_uv(uv3)
	st.add_vertex(v3)



"

[sub_resource type="SphereMesh" id="SphereMesh_1vphk"]
material = ExtResource("5_d1wt7")

[sub_resource type="SphereShape3D" id="SphereShape3D_c0nvr"]

[sub_resource type="Gradient" id="Gradient_nh6m4"]
interpolation_mode = 2
offsets = PackedFloat32Array(0, 0.369748, 0.584034, 1)
colors = PackedColorArray(1, 1, 1, 0, 1, 0.820879, 1, 0.390393, 0.937611, 0.449649, 0.948988, 0.604681, 0.843186, 0.000662472, 0.861032, 1)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_bj44f"]
gradient = SubResource("Gradient_nh6m4")

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_a7pyk"]
transparency = 1
shading_mode = 0
albedo_texture = SubResource("GradientTexture1D_bj44f")

[sub_resource type="GDScript" id="GDScript_u70bb"]
script/source = "class_name Trail3D extends MeshInstance3D

enum {VIEW, NORMAL, OBJECT}
enum {X, Y, Z}

@export var emit: bool = true
@export var distance: float= 0.1
@export_range(0, 99999) var segments: int = 20
@export var lifetime: float= 0.5
@export_range(0, 99999) var base_width: float =  0.5
@export var tiled_texture: bool = false
@export var tiling: int = 0
@export var width_profile: Curve
@export_range(0, 3) var smoothing_iterations: int= 0
@export_range(0, 0.5) var smoothing_ratio: float = 0.25
@export_enum(\"VIEW\", \"NORMAL\", \"OBJECT\") var alignment: int = 0
@export_enum(\"X\", \"Y\", \"Z\") var axe: int = 1


var points := []
var color := Color(1, 1, 1, 1)
var always_update = false

var _target: Node3D
var _A: Point
var _B: Point
var _C: Point
var _temp_segment := []
var _points := []


class Point:
	var transform: Transform3D
	var age: float = 0.0

	func _init(transform :Transform3D, age :float) -> void:
		transform = transform
		age = age
	
	func update(delta: float, points: Array) -> void:
		age -= delta
		if age <= 0:
			points.erase(self)





func add_point(transform :Transform3D) -> void:
	var point =  Point.new(transform, lifetime)
	points.push_back(point)


func clear_points() -> void:
	points.clear()


func _prepare_geometry(point_prev :Point, point :Point, half_width :float, factor :float) -> Array:
	var normal := Vector3()
	
	if alignment == VIEW:
		if get_viewport().get_camera_3d():
			var cam_pos = get_viewport().get_camera_3d().get_global_transform().origin
			var path_direction :Vector3 = (point.transform.origin - point_prev.transform.origin).normalized()
			normal = (cam_pos - (point.transform.origin + point_prev.transform.origin)/2).cross(path_direction).normalized()
		else:
			print(\"There is no camera in the scene\")
			
	elif alignment == NORMAL:
		if axe == X:
			normal = point.transform.basis.x.normalized()
		elif axe == Y:
			normal = point.transform.basis.y.normalized()
		else:
			normal = point.transform.basis.z.normalized()
	
	else:
		if axe == X:
			normal = _target.global_transform.basis.x.normalized()
		elif axe == Y:
			normal = _target.global_transform.basis.y.normalized()
		else:
			normal = _target.global_transform.basis.z.normalized()

	var width = half_width
	if width_profile:
		width = half_width * width_profile.sample(factor)

	var p1 = point.transform.origin-normal*width
	var p2 = point.transform.origin+normal*width
	return [p1, p2]


func render(update := false) -> void:
	if update:
		always_update = update
	else:
		_render_geometry(points)


func _render_realtime() -> void:
	var render_points = _points+_temp_segment+[_C]
	_render_geometry(render_points)


func _render_geometry(source: Array) -> void:
	var points_count = source.size()
	if points_count < 2:
		return

	# The following section is a hack to make orientation \"view\" work.
	# but it may cause an artifact at the end of the trail.
	# You can use transparency in the gradient to hide it for now.
	var _d :Vector3 = source[0].transform.origin - source[1].transform.origin
	var _t :Transform3D = source[0].transform
	_t.origin = _t.origin + _d
	var point = Point.new(_t, source[0].age)
	var to_be_rendered = [point]+source
	points_count += 1

	var half_width :float = base_width/2.0
	var u := 0.0

	mesh.clear_surfaces()
	mesh.surface_begin(Mesh.PRIMITIVE_TRIANGLE_STRIP, null)
	for i in range(1, points_count):
		var factor :float = float(i)/(points_count-1)

		var vertices = _prepare_geometry(to_be_rendered[i-1], to_be_rendered[i], half_width, 1.0-factor)
		if tiled_texture:
			if tiling > 0:
				factor *= tiling
			else:
				var travel = (to_be_rendered[i-1].transform.origin - to_be_rendered[i].transform.origin).length()
				u += travel/base_width
				factor = u

		
		mesh.surface_set_uv(Vector2(factor, 0))
		mesh.surface_add_vertex(vertices[0])
		mesh.surface_set_uv(Vector2(factor, 1))
		mesh.surface_add_vertex(vertices[1])


	mesh.surface_end()



func _update_points() -> void:
	var delta = get_process_delta_time()
		
	_A.update(delta, _points)
	_B.update(delta, _points)
	_C.update(delta, _points)
	for point in _points:
		point.update(delta, _points)

	var size_multiplier = [1, 2, 4, 6][smoothing_iterations]
	var max_points_count :int = segments * size_multiplier
	if _points.size() > max_points_count:
		_points.reverse()
		_points.resize(max_points_count)
		_points.reverse()


func smooth() -> void:
	if points.size() < 3:
		return

	var output := [points[0]]
	for i in range(1, points.size()-1):
		output += _chaikin(points[i-1], points[i], points[i+1])
		
	output.push_back(points[-1])
	points = output


func _chaikin(A, B, C) -> Array:
	if smoothing_iterations == 0:
		return [B]

	var out := []
	var x :float = smoothing_ratio

	# Pre-calculate some parameters to improve performance
	var xi  :float = (1-x)
	var xpa :float = (x*x-2*x+1)
	var xpb :float = (-x*x+2*x)
	# transforms
	var A1_t  :Transform3D = A.transform.interpolate_with(B.transform, xi)
	var B1_t  :Transform3D = B.transform.interpolate_with(C.transform, x)
	# ages
	var A1_a  :float = lerp(A.age, B.age, xi)
	var B1_a  :float = lerp(B.age, C.age, x)

	if smoothing_iterations == 1:
		out = [Point.new(A1_t, A1_a), Point.new(B1_t, B1_a)]

	else:
		# transforms
		var A2_t  :Transform3D = A.transform.interpolate_with(B.transform, xpa)
		var B2_t  :Transform3D = B.transform.interpolate_with(C.transform, xpb)
		var A11_t :Transform3D = A1_t.interpolate_with(B1_t, x)
		var B11_t :Transform3D = A1_t.interpolate_with(B1_t, xi)
		# ages
		var A2_a  :float = lerp(A.age, B.age, xpa)
		var B2_a  :float = lerp(B.age, C.age, xpb)
		var A11_a :float = lerp(A1_a, B1_a, x)
		var B11_a :float = lerp(A1_a, B1_a, xi)

		if smoothing_iterations == 2:
			out += [Point.new(A2_t, A2_a), Point.new(A11_t, A11_a),
					Point.new(B11_t, B11_a), Point.new(B2_t, B2_a)]
		elif smoothing_iterations == 3:
			# transforms
			var A12_t  :Transform3D = A1_t.interpolate_with(B1_t, xpb)
			var B12_t  :Transform3D = A1_t.interpolate_with(B1_t, xpa)
			var A121_t :Transform3D = A11_t.interpolate_with(A2_t, x)
			var B121_t :Transform3D = B11_t.interpolate_with(B2_t, x)
			# ages
			var A12_a  :float = lerp(A1_a, B1_a, xpb)
			var B12_a  :float = lerp(A1_a, B1_a, xpa)
			var A121_a :float = lerp(A11_a, A2_a, x)
			var B121_a :float = lerp(B11_a, B2_a, x)
			out += [Point.new(A2_t, A2_a), Point.new(A121_t, A121_a), Point.new(A12_t, A12_a),
					Point.new(B12_t, B12_a), Point.new(B121_t, B121_a), Point.new(B2_t, B2_a)]

	return out


func _emit(delta) -> void:
	var _transform :Transform3D = _target.global_transform

	var point = Point.new(_transform, lifetime)
	if not _A:
		_A = point
		return
	elif not _B:
		_A.update(delta, _points)
		_B = point
		return

	if _B.transform.origin.distance_squared_to(_transform.origin) >= distance*distance:
		_A = _B
		_B = point
		_points += _temp_segment
		
	_C = point

	_update_points()
	_temp_segment = _chaikin(_A, _B, _C)
	_render_realtime()



func _ready() -> void:
	mesh = ImmediateMesh.new()
	_target = get_parent()
	top_level = true



func _process(delta) -> void:
	if emit:
		_emit(delta)
		return
		
	if always_update:
		# This is needed for alignment == view, so it can be updated every frame.
		_render_geometry(points)
"

[sub_resource type="Curve" id="Curve_su4bn"]
_data = [Vector2(0, 1), 0.0, 0.0, 0, 0, Vector2(1, 0.218182), 0.0, 0.0, 0, 0]
point_count = 2

[sub_resource type="PanoramaSkyMaterial" id="PanoramaSkyMaterial_vcrrc"]
panorama = ExtResource("6_x4oj4")
filter = false

[sub_resource type="Sky" id="Sky_wiiuw"]
sky_material = SubResource("PanoramaSkyMaterial_vcrrc")

[sub_resource type="Environment" id="Environment_4foyh"]
background_mode = 2
background_energy_multiplier = 0.3
sky = SubResource("Sky_wiiuw")
ambient_light_source = 2
ambient_light_color = Color(1, 1, 1, 1)
ambient_light_energy = 0.04

[node name="Node3D2" type="Node3D"]

[node name="CameraPivot" type="Node3D" parent="."]
process_mode = 3
transform = Transform3D(0.66262, 0.251238, -0.705559, 0, 0.942057, 0.335452, 0.748956, -0.222277, 0.624226, 0, 0, 0)
script = ExtResource("1_uivi6")

[node name="Camera3D" type="Camera3D" parent="CameraPivot"]
unique_name_in_owner = true
transform = Transform3D(1, -2.32831e-10, 0, 0, 1, 1.49012e-08, -1.86265e-09, -1.49012e-08, 1, 0, 0, 30)

[node name="GravityObject" parent="." instance=ExtResource("2_kb70h")]

[node name="GravityObject2" parent="." instance=ExtResource("3_vnnaq")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 34.6721, 0, 0)
mass = 0.1
linear_velocity = Vector3(0, 2.5, 0)
script = SubResource("GDScript_d487t")
width = 0.5
width_curve = null
max_points = 100
material = null
render = true

[node name="GravityObject3" type="RigidBody3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.136, 0, 15)
mass = 0.01
linear_velocity = Vector3(6, -2, 0)
script = ExtResource("4_tpk38")

[node name="MeshInstance3D" type="MeshInstance3D" parent="GravityObject3"]
mesh = SubResource("SphereMesh_1vphk")

[node name="CollisionShape3D" type="CollisionShape3D" parent="GravityObject3"]
shape = SubResource("SphereShape3D_c0nvr")

[node name="Trail_3d" type="MeshInstance3D" parent="GravityObject3"]
material_override = SubResource("StandardMaterial3D_a7pyk")
script = SubResource("GDScript_u70bb")
distance = 1.202
segments = 899
lifetime = 0.86
base_width = 5558.32
tiled_texture = true
width_profile = SubResource("Curve_su4bn")

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_4foyh")

[node name="CanvasLayer" type="CanvasLayer" parent="."]
process_mode = 3

[node name="Interface" type="Control" parent="CanvasLayer"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="MineToolbar" type="TextureRect" parent="CanvasLayer/Interface"]
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -344.0
offset_top = -94.0
offset_right = 351.0
offset_bottom = -23.0
grow_horizontal = 2
grow_vertical = 0
texture = ExtResource("7_u3wvk")

[node name="DragNDropTest" type="TextureRect" parent="CanvasLayer/Interface/MineToolbar"]
layout_mode = 1
anchors_preset = -1
offset_left = 105.0
offset_top = 12.0
offset_right = 155.0
offset_bottom = 62.0
texture = ExtResource("8_wjos7")
expand_mode = 1
script = ExtResource("9_wwimo")

[node name="AnalyticPause" type="Control" parent="CanvasLayer"]
process_mode = 3
layout_mode = 3
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -40.0
offset_bottom = 40.0
grow_horizontal = 0
script = ExtResource("10_cwwdn")

[node name="Pause Button" type="Button" parent="CanvasLayer/AnalyticPause"]
layout_mode = 1
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -81.0
offset_top = 12.0
offset_right = -26.0
offset_bottom = 43.0
grow_horizontal = 0
text = "Pause"

[node name="SaveAndLoad" parent="CanvasLayer" instance=ExtResource("11_ft4fd")]

[connection signal="mouse_entered" from="CanvasLayer/Interface/MineToolbar/DragNDropTest" to="CanvasLayer/Interface/MineToolbar/DragNDropTest" method="_on_mouse_entered"]
[connection signal="mouse_exited" from="CanvasLayer/Interface/MineToolbar/DragNDropTest" to="CanvasLayer/Interface/MineToolbar/DragNDropTest" method="_on_mouse_exited"]
[connection signal="pressed" from="CanvasLayer/AnalyticPause/Pause Button" to="CanvasLayer/AnalyticPause" method="_on_pause_button_pressed"]
